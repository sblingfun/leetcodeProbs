//Additional work with two hashmap solution (DOES NOT WORK)
class Solution {
    public List<Integer> findSubstring(String s, String[] words) {
        //initalize return list
        List<Integer> retList = new ArrayList<Integer>();

        //add all words to HashMap
        HashMap<String,Integer> wordList = new HashMap<String,Integer>();
        for (String word : words) {
            int num = wordList.getOrDefault(word,0);
            wordList.put(word,num + 1);
        }
        //HashMap to keep track of removed words
        HashMap<String,Integer> curList = new HashMap<String,Integer>();

        int wrdLen = words[0].length();
        int numWrds = words.length;
        int concatSize = wrdLen * numWrds;
        int leadPtr = 0;
        int trailPtr = 0;
        
        while (leadPtr <= s.length() - concatSize) {
            //pull next word
            String temp = s.substring(leadPtr, leadPtr + wrdLen);
            //move up

            //see if temp is in wordList use Integer b/c nullable
            Integer val = wordList.get(temp);

            //if temp in wordList
            if (val != null) {
                //check if curList is full
                if (leadPtr - trailPtr > concatSize) {
                    word
                }
                //remove if 1 otherwise reduce
                if (val == 1) {
                    wordList.remove(temp);
                    //add to removed list adding 1 to value if already present
                    curList.put(temp,curList.getOrDefault(temp,0) + 1);
                }
                else {
                    wordList.put(temp,val - 1);
                    curList.put(temp,curList.getOrDefault(temp,0) + 1);
                }
                if (wordList.isEmpty()) {
                    retList.add(trailPtr);
                }
                leadPtr += wrdLen;
            }

            else {
                //not in list have to start over take all words from curList and add back to wordList
                for (String key : curList.keySet() ) {
                    //add value in curlist to current Val in wordList
                    wordList.put(key, curList.get(key) + wordList.getOrDefault(key,0));
                }

                trailPtr = leadPtr;
                leadPtr++;
            }   
        }            
        return retList;
    }
}

//Adding solution that would work if not having to iterate through the entire array but by word size (doesnt end up working)
class Solution {
    public List<Integer> findSubstring(String s, String[] words) {
        //initalize return list
        List<Integer> retList = new ArrayList<Integer>();

        //add all words to HashMap
        HashMap<String,Integer> wordList = new HashMap<String,Integer>();
        for (String word : words) {
            int num = wordList.getOrDefault(word,0);
            wordList.put(word,num + 1);
        }
        //HashMap to keep track of removed words
        HashMap<String,Integer> curList = new HashMap<String,Integer>();

        int wrdLen = words[0].length();
        int numWrds = words.length;
        int concatSize = wrdLen * numWrds;
        int leadPtr = 0;
        int trailPtr = 0;
        
        while (leadPtr <= s.length() - wrdLen) {
            //pull next word
            String temp = s.substring(leadPtr, leadPtr + wrdLen);
            //System.out.println("Trail: " + trailPtr + " lead: " + leadPtr + " curWrd: " + temp);
            //System.out.println(wordList.keySet());
            
            curList.put(temp,curList.getOrDefault(temp,0) + 1);
            
            if (leadPtr >= concatSize) {
                String toRmv = s.substring(trailPtr, trailPtr + wrdLen);
                int num = curList.get(toRmv);
                if (num == 1) {
                    curList.remove(toRmv);
                }
                else {
                    curList.put(toRmv, num - 1);
                }
                trailPtr += wrdLen;
            }
            
            //if lists match
            if (curList.equals(wordList)) {
                retList.add(trailPtr);
            }

            //increment next word
            leadPtr += wrdLen;
        }
        return retList;
    }
}

//adding my own work
//this solution is incomplete
class Solution {
    public List<Integer> findSubstring(String s, String[] words) {
        //initalize return list
        List<Integer> retList = new ArrayList<Integer>();

        //add all words to HashMap
        HashMap<String,Integer> wordList = new HashMap<String,Integer>();
        for (String word : words) {
            int num = wordList.getOrDefault(word,0);
            wordList.put(word,num + 1);
        }
        //HashMap to keep track of removed words
        HashMap<String,Integer> removeList = new HashMap<String,Integer>();

        int wrdLen = words[0].length();
        int numWrds = words.length;
        int concatSize = wrdLen * numWrds;
        int leadPtr = 0;
        int trailPtr = 0;
        
        while (leadPtr <= s.length() - concatSize) {
            

            
            
            //pull next word
            String temp = s.substring(leadPtr, leadPtr + wrdLen);
            System.out.println("Trail: " + trailPtr + " lead: " + leadPtr + " curWrd: " + temp);
            System.out.println(wordList.keySet());
            //check if word is in word list
            //Using Integer instead of int to allow nullable
            Integer num = wordList.get(temp);
            //word is in wordlist
            if (num != null) {
                //if reached end of current range remove trailing word
                if (leadPtr - trailPtr >= concatSize) {
                    String addBack = s.substring(trailPtr, trailPtr + wrdLen);
                    int num2 = wordList.getOrDefault(addBack,0);
                    wordList.put(addBack,num2 + 1);
                }
                //if only 1 element can be removed
                if (num == 1) {
                    wordList.remove(temp);
                }
                //can decrement count in map
                else {
                    wordList.put(temp, num - 1);
                }
                //add value to remove list
                int num3 = removeList.getOrDefault(temp,0);
                removeList.put(temp, num3 + 1);
            }
            //word not in list, start over and reset map
            else {
                //wordList.clear();
                for (String word : removeList.keySet()) {
                    int num2 = removeList.get(word);
                    wordList.put(word,num2);
                }
                removeList.clear();
                trailPtr = leadPtr + wrdLen;
            }
            //check if all words gone from list then add value to answer
            if (wordList.isEmpty()) {
                retList.add(trailPtr);
            }

            //next word 
            leadPtr += wrdLen;
        }
        return retList;
        


    }
}

public static List<Integer> findSubstring(String S, String[] L) {
    List<Integer> res = new ArrayList<Integer>();
    if (S == null || L == null || L.length == 0) return res;
    int len = L[0].length(); // length of each word
    
    Map<String, Integer> map = new HashMap<String, Integer>(); // map for L
    for (String w : L) map.put(w, map.containsKey(w) ? map.get(w) + 1 : 1);
    
    for (int i = 0; i <= S.length() - len * L.length; i++) {
        Map<String, Integer> copy = new HashMap<String, Integer>(map);
        for (int j = 0; j < L.length; j++) { // checkc if match
            String str = S.substring(i + j*len, i + j*len + len); // next word
            if (copy.containsKey(str)) { // is in remaining words
                int count = copy.get(str);
                if (count == 1) copy.remove(str);
                else copy.put(str, count - 1);
                if (copy.isEmpty()) { // matches
                    res.add(i);
                    break;
                }
            } else break; // not in L
        }
    }
    return res;
}
